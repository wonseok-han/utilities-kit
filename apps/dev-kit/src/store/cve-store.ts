import { fetchCVEById, fetchRecentCVEs } from '@services/cve';
import { create } from 'zustand';

// ìƒìˆ˜ ì •ì˜
const ERROR_COOLDOWN_MS = 3000; // ì—ëŸ¬ ë°œìƒ í›„ 3ì´ˆ ëŒ€ê¸°
const CVE_PAGE_SIZE = 50; // í•œ í˜ì´ì§€ë‹¹ CVE ê°œìˆ˜

interface CVEState {
  cves: CVEDataType[];
  isLoading: boolean;
  isLoadingMore: boolean;
  error: string | null;
  lastUpdated: string | null;
  currentPage: number;
  hasMore: boolean;
  totalResults: number;
  lastErrorTime: number | null; // ë§ˆì§€ë§‰ ì—ëŸ¬ ë°œìƒ ì‹œê°„

  // ì•¡ì…˜
  fetchRecentCVEs: ({ page }: { page: number }) => Promise<void>;
  loadMoreCVEs: () => Promise<void>;
  fetchCVEById: (id: string) => Promise<CVEDataType | null>;
  clearError: () => void;
  setInitialData: (cves: CVEDataType[], error: string | null) => void;
  resetPagination: () => void;
}

export const useCVEStore = create<CVEState>((set, get) => ({
  cves: [],
  isLoading: false,
  isLoadingMore: false,
  error: null,
  lastUpdated: null,
  currentPage: 0,
  hasMore: true,
  totalResults: 0,
  lastErrorTime: null,

  fetchRecentCVEs: async ({ page = 1 }) => {
    set({ isLoading: true, error: null, currentPage: page });

    try {
      const result = await fetchRecentCVEs(page, CVE_PAGE_SIZE);
      set({
        cves: [...result.cves.reverse()],
        isLoading: false,
        lastUpdated: new Date().toISOString(),
        currentPage: result.pagination.currentPage,
        hasMore: result.pagination.hasMore,
        totalResults: result.pagination.totalResults,
      });
    } catch (error) {
      set({
        error:
          error instanceof Error ? error.message : 'Failed to fetch CVE data',
        isLoading: false,
      });
    }
  },

  loadMoreCVEs: async () => {
    const { currentPage, hasMore, isLoadingMore, lastErrorTime } = get();

    // ì—ëŸ¬ ë°œìƒ í›„ ì¼ì • ì‹œê°„ ë™ì•ˆ ì¶”ê°€ ìš”ì²­ ì°¨ë‹¨
    if (lastErrorTime && Date.now() - lastErrorTime < ERROR_COOLDOWN_MS) {
      console.log('ğŸš« Skipping loadMoreCVEs due to recent error');
      return;
    }

    if (!hasMore || isLoadingMore) return;

    set({ isLoadingMore: true });

    try {
      const nextPage = currentPage - 1;
      const result = await fetchRecentCVEs(nextPage, CVE_PAGE_SIZE);

      set((state) => {
        // ì¤‘ë³µëœ CVE IDë¥¼ í•„í„°ë§í•˜ì—¬ ì œê±°
        const existingIds = new Set(state.cves.map((cve) => cve.id));
        const newCves = result.cves.filter((cve) => !existingIds.has(cve.id));

        return {
          cves: [...state.cves, ...newCves.reverse()],
          isLoadingMore: false,
          currentPage: result.pagination.currentPage,
          hasMore: result.pagination.hasMore,
          totalResults: result.pagination.totalResults,
        };
      });
    } catch (error) {
      set({
        error:
          error instanceof Error
            ? error.message
            : 'Failed to load more CVE data',
        isLoadingMore: false,
        lastErrorTime: Date.now(), // ì—ëŸ¬ ë°œìƒ ì‹œê°„ ê¸°ë¡
      });
    }
  },

  fetchCVEById: async (id: string) => {
    set({ isLoading: true, error: null });

    try {
      const cve = await fetchCVEById(id);
      set({ isLoading: false });
      return cve;
    } catch (error) {
      set({
        error:
          error instanceof Error ? error.message : 'Failed to fetch CVE data',
        isLoading: false,
      });
      return null;
    }
  },

  clearError: () => set({ error: null }),

  setInitialData: (cves: CVEDataType[], error: string | null) => {
    // ì´ˆê¸° ë°ì´í„°ê°€ í˜ì´ì§€ í¬ê¸° ë¯¸ë§Œì´ë©´ ë” ì´ìƒ ë¡œë“œí•  ë°ì´í„°ê°€ ì—†ë‹¤ê³  ê°€ì •
    const hasMore = cves.length >= CVE_PAGE_SIZE;

    set({
      cves,
      error,
      isLoading: false,
      lastUpdated: error ? null : new Date().toISOString(),
      currentPage: 1,
      hasMore,
      totalResults: cves.length,
    });
  },

  resetPagination: () => {
    set({
      currentPage: 0,
      hasMore: true,
      totalResults: 0,
    });
  },
}));

import { fetchCVEById, fetchRecentCVEs } from '@services/cve';
import { create } from 'zustand';

// 상수 정의
const ERROR_COOLDOWN_MS = 3000; // 에러 발생 후 3초 대기
const CVE_PAGE_SIZE = 50; // 한 페이지당 CVE 개수

interface CVEState {
  cves: CVEDataType[];
  isLoading: boolean;
  isLoadingMore: boolean;
  error: string | null;
  lastUpdated: string | null;
  currentPage: number;
  hasMore: boolean;
  totalResults: number;
  lastErrorTime: number | null; // 마지막 에러 발생 시간

  // 액션
  fetchRecentCVEs: ({ page }: { page: number }) => Promise<void>;
  loadMoreCVEs: () => Promise<void>;
  fetchCVEById: (id: string) => Promise<CVEDataType | null>;
  clearError: () => void;
  setInitialData: (cves: CVEDataType[], error: string | null) => void;
  resetPagination: () => void;
}

export const useCVEStore = create<CVEState>((set, get) => ({
  cves: [],
  isLoading: false,
  isLoadingMore: false,
  error: null,
  lastUpdated: null,
  currentPage: 0,
  hasMore: true,
  totalResults: 0,
  lastErrorTime: null,

  fetchRecentCVEs: async ({ page = 1 }) => {
    set({ isLoading: true, error: null, currentPage: page });

    try {
      const result = await fetchRecentCVEs(page, CVE_PAGE_SIZE);
      set({
        cves: [...result.cves.reverse()],
        isLoading: false,
        lastUpdated: new Date().toISOString(),
        currentPage: result.pagination.currentPage,
        hasMore: result.pagination.hasMore,
        totalResults: result.pagination.totalResults,
      });
    } catch (error) {
      set({
        error:
          error instanceof Error ? error.message : 'Failed to fetch CVE data',
        isLoading: false,
      });
    }
  },

  loadMoreCVEs: async () => {
    const { currentPage, hasMore, isLoadingMore, lastErrorTime } = get();

    // 에러 발생 후 일정 시간 동안 추가 요청 차단
    if (lastErrorTime && Date.now() - lastErrorTime < ERROR_COOLDOWN_MS) {
      console.log('🚫 Skipping loadMoreCVEs due to recent error');
      return;
    }

    if (!hasMore || isLoadingMore) return;

    set({ isLoadingMore: true });

    try {
      const nextPage = currentPage - 1;
      const result = await fetchRecentCVEs(nextPage, CVE_PAGE_SIZE);

      set((state) => {
        // 중복된 CVE ID를 필터링하여 제거
        const existingIds = new Set(state.cves.map((cve) => cve.id));
        const newCves = result.cves.filter((cve) => !existingIds.has(cve.id));

        return {
          cves: [...state.cves, ...newCves.reverse()],
          isLoadingMore: false,
          currentPage: result.pagination.currentPage,
          hasMore: result.pagination.hasMore,
          totalResults: result.pagination.totalResults,
        };
      });
    } catch (error) {
      set({
        error:
          error instanceof Error
            ? error.message
            : 'Failed to load more CVE data',
        isLoadingMore: false,
        lastErrorTime: Date.now(), // 에러 발생 시간 기록
      });
    }
  },

  fetchCVEById: async (id: string) => {
    set({ isLoading: true, error: null });

    try {
      const cve = await fetchCVEById(id);
      set({ isLoading: false });
      return cve;
    } catch (error) {
      set({
        error:
          error instanceof Error ? error.message : 'Failed to fetch CVE data',
        isLoading: false,
      });
      return null;
    }
  },

  clearError: () => set({ error: null }),

  setInitialData: (cves: CVEDataType[], error: string | null) => {
    // 초기 데이터가 페이지 크기 미만이면 더 이상 로드할 데이터가 없다고 가정
    const hasMore = cves.length >= CVE_PAGE_SIZE;

    set({
      cves,
      error,
      isLoading: false,
      lastUpdated: error ? null : new Date().toISOString(),
      currentPage: 1,
      hasMore,
      totalResults: cves.length,
    });
  },

  resetPagination: () => {
    set({
      currentPage: 0,
      hasMore: true,
      totalResults: 0,
    });
  },
}));
